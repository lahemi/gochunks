The `macroLoad`er ignores everything that
is not between brackets, so no need for
a separate comment syntax!

First we assign the exposed
functions to shorthands.

(jumpChar    â†’ j)
(jumpChar    â†’ j)
(curLoadChar â†’ y)
(putChar     â†’ p)
(searchCharF â†’ s)
(searchCharB â†’ r)
(deleteChar  â†’ d)
(insert      â†’ i)
(printChar   â†’ o)

(quit       â†’ q)
(writeFile  â†’ w)
(changeFile â†’ c)

(addition       â†’ +)
(subtraction    â†’ -)
(multiplication â†’ Ã—)
(division       â†’ Ã·)

(eof        â†’ EOF)
(repeatCmd  â†’ rep)
(currentPos â†’ cur)

Move one char forward and backward.
(cur 1 + j â†’ 1f)
(cur 1 - j â†’ 1b)

Move to the start of line, and handle
the special case of start of a file
(cur `\n` r [ - 1 + | cur - ] j â†’ ^)
move to the end of a line
(cur `\n` s + 1 - j â†’ $)

(cur 1 + j o â†’ 1o)

Prints till the end of line
(o `\n` s `1o` rep cur 1 - j â†’ pl)

Print the current line
(^ pl ^ â†’ println)

Print line and move to the next line
(println $ 1f 1f â†’ spl)

($ 1f 1f   â†’ next-line)
(next-line â†’ )
(^ 1b 1b ^ â†’ prev-line)
(prev-line â†’ )

(cur ` ` s + j â†’ forward-word)
(forward-word  â†’ )
(cur ` ` r - j â†’ backward-word)
(backward-word â†’ )

The arg to this is not really visible here.
Move to the beginning of the file, and
then just repeat next-line given times,
ie. 5 `goto-line` goes to the line 6.
This is quite inefficient though, the
larger the file and the deeper the
desired line is. On the more positive
note though, this'd be the thing to do
anyway when printing the line numbers,
though not really relevant here.
(0 j `next-line` rep â†’ goto-line)


(` ` s `d` rep â†’ forward-word-delete)
(forward-word-delete  â†’ fwd)
(backward-word fwd    â†’ backward-word-delete)
(backward-word-delete â†’ bwd)

(^ `\n` s `d` rep â†’ delete-line)

(y upperChar d i â†’ char-upper)
(y lowerChar d i â†’ char-lower)

